- Use with Visual Studio Code
	Follow the guide on the course 
	Install the mingw64 compiler 

	Compile: 
		Select the main.cpp file and press CTRL + SHIFT + B 
	
	Execute: 
		Select the executable file, right click and select "open in integrated terminal" 
		From here: .\[ExecutablefileName] to run 

	Debugger: 
		Select the main.cpp file and press the debug button on the left
			classic debugger
	
	Prepare other projects to VS Code:
		Copy the .vscode folder in the project root 
	
- c++ standards: 
    classic:    c++98, c++03, 
    modern:     c++11, c++14, c++17, c++20, c++23 
    modern = way of c++ works today
	
- extensions:
	.h      header (declarations)
    .cpp    implementation (definitions)
	
- compiled language:
    main.cpp    main file
    others .cpp files 
    They are compiled to Object Code. 
    Then they are linked -> an executable is created

- syntax error: 
	missing some character, like a comma or a brace
	
- semantic error: 
	wrong type of elements in functions calls
	
- compiler warnings:
	they do no stop the program from being build, but they are important anyway, like 
	- usage of a uninitialized variable
	- variable defined dut not used
	
- linker errors:
	when a library needed is not found
	
- preprocessor: 
	program that process the source code before the compiler sees it 
	preprocessors directive start with a # symbol
	
- comments: 
	// line comment 
	/* multiline comment ...	*/ 
	
- main function: 
	every cpp program must have 1 main function somewhere. 
	main function is called by the operating system 
	int main() {}
		no parameters passed by the operating system 
	int main(int argc, char** argv) {} 
		with these one we have argument count (argc) 
		and a vector of strings
	return 0; at the end
	
- namespaces: 
	:: scope resolution operator
	using namespace std; --> no need of typing std:: everytime
		but it imports all std functions!
	using std::cout; fully qualifies cout from std namespace
		not anything else (not importing useless code)
		
- endl vs \n: \n does not flush the buffer 

- cin ignores spaces and tab
	if multiple inputs are given, cin buffer reads them and uses them 
	on need. 
	
- variable initialization: 
	int age;
	int age = 21; // c-like initialization
	int age (21); // constructor initialization
	int age {21}; // c++11 list initialization syntax, better 
	
- global variables: 
	they can be access from any part of the program 
	they are defined outside function, and are seen by all function
	they can be accessed and changed by any part of the program 
	
- Types:
	- int:
		signed/unsigned short/ /long/long long int 
		signed can be omitted 
		length:
			short 	at least 16 bit 
			none 	at least 16 bit
			long 	32 bits 
			long long 	64 bits 
		if length is present, then int is not required
	- char:
		- char 	8 bits (we use this) 
		- char_16 16 bits
		...
	- floating point:
		- float: 7 decimal digits 
		- double: no less than float integer digit, 15 decimal digits 
		- long double no less than float integer digiti, 19 decimal digits 
	- bool: 
		0 is false, or false keyword
		non 0 value is true, or true keyword
		
- sizeof: tells the size inf bytes of the type provided 
	sizeof(int)
	sizeof(double)
	sizeof(var_name) (can also provide a variable)
	sizeof var_name (round brackets are not necessary)
	
- climits and cfloat 
	contains size and precision information about c++ implementation
	
- constant: 
	like a variable, usually typed, but once declared, cannot change value anymore after that 
	escape codes are constants (\n, \t ...)
	
	const double pi {3.1415926};
	const int months_in_year {12};
	pi = 2.5; // error 
	
	we can also define constants, using #
	do not use this with modern c++, since it is not scoped 
	
	#define pi 3.1415926
	
- Array: 
	data structure of elements of same type 
	Fixed in size! 
	Stored continuously in memory 
	First element at index 0, last at Size-1
	No out-of-bound checks 
	
	type name [size] -> size can also be a const declared before
	
	initialization: 
		int xs [5] {100, 99, 97, 98, 93};
		int xs [10] {1, 2} others are set to 0 
		int xs [size] {0} initi all to zero
		int xs [] {1,4,3,6,6} compiler infers the size of the array, starting from the list initialization
		
	access: 
		xs [index]
		
	implementation: 
		name of the array = address of first element
		index = offset with respect to address of first element 
		
- Multidimensional array: 
	type name [size1] [size2]
	
	int movie_rating [3] [4]; 
	
	const int rows {3};
	const int cols {4};
	int movie_rating [rows] [cols];
	cin >> movie_rating [1] [1];
	cout << movie_rating [2] [3];
	
	initialization: initialized by rows
		int movie_rating [3] [4]
		{
			{0,1,2,3},
			{3,2,4,1},
			{2,4,2,5}
		}
		
- Vectors:
	When the size is unknown, use vectors -> Dynamic size Array 
	Array that can grow and shrink in size at execution time 
	Similar semantics and sntax as array 
	Very efficient 
	Bound checking 
	Provides functions like sort, revers, find and more... 
	
	#include <vector> 
	using namespace std; 
	
	vector <char> vowels; // ovject oriented template class! Parametric w.r.t. contained type 
	vector <int> test_scores; 
	
	Declaration: we specify the size, and if int type, automatically set to 0
	vector <char> vowels (5); // object constructor 
	vector <int> test_scores (10); 
	
	We can also use initializer list 
	vector <char> vowels {'a','e','i','o','u'};
	vector <double> hi_temps {352, 80.2};
	
	(Difference with list: vectors are implemented with arrays underneath,
	while lists use pointers to next element)
	
	Access: (2 equivalent ways)
		vector[index];
		vector.at(index);
		
		// append an element to the end of the array 
		// internally increases array size 
		// push_back method copy element inside the vector
		vector.push_back(element); 
	
	Bound checking:
		provided if vector accessed with .at method!
		
	Size: 
		vector.size(); // returns vector's size
		
- Statements: 
	line of code that complete one action 
	
- Operators: 
	can be unary, binary, ternary 
	Types:
		- assignment 
		- arithmetic
		- increment/decrement
		- relational 
		- logical 
		- member access 
		- others...
	
- Assignment Operator: 
	lhs = rhs
		rhs is evaluated as a value 
		that value is given to the lhs 
		
		rhs value must be compatible with lhs type 
		lhs must be assignable (no literal or constant) 
		
		chained assignment are possible
		
		r-value = content of variable 
		l-value = location of variable
		
		type checking between lhs and rhs is done at COMPILE time 
		
		assignment operator returns the value assigned, like 
		T = (T lhs, T rhs) 
		
- Arithmetic Operators 
	% works only with integers! 
	
- Increment Decrement Operators: 
	2 variants: prefix and postfix notation
		- prefix: 	++num;
		- postfix: 	num++;
		
	The 2 variants have different effects when used as r-value: 
		- prefix: ++num first increment, then get the value 
		- postfix: num++ first get value, then increment
		
		    res = ++num; 
		        EQUIVALENT TO 
			num = num + 1;
			res = num;
			
		    res = num++; 
		        EQUIVALENT TO 
			res = num;
			num = num + 1;
			
- Mixed Type Expressions: cast
	c++ try to convert one of the operand to match the other (automatic conversion = coercion)
	Higher vs Lower types 
		- from lower to higher always possible 
		- from higher to lower can induce loss of precision 
	Type Coercion = conversion of one operand to another data type 
	Promotion = from lower to higher -> used in mathematical expression : 2 * 5.2 // 2 is promoted to 2.0
	Demotion = from higher to lower -> used in assignment to lower : int num = 100.2 // 100.2 float is converted to 100, demotion 
	
	Types of casts:
		(T)var; // old style C cast, DO NOT USE IT!!

		static_cast<T>(var) 
			Compile time cast
			No runtime checks
			converts var from its type to type T 
			avg = static_cast<double>(sum)/count;
			It checks also if var can be converted to type T! USE THIS!!

		dynamic_cast<T>(var)
			Runtime cast with runtime checks 
			Tries to convert type of var to type T 
			T must be a type inheriting from type of var
			If it fails: 
				- return nullptr or std::bad_cast
			eg: 
				Shape* var = new Shape();
				Square* squareVar = dynamic_cast<Square*>(var);
	
- Testing for Equality: (classic)

- Comparisons: 
	>,<, ... 
	<=> in c++20 : a <=> b 
					negative value if a greater 
					0 if Equals
					positive value if b greater 
	
- logical operators:
	! has highest precedence 
	&& has a greater precedence than || 
	
	short circuit evaluation: 
		c++ stops evaluating an expression as soon as it has the result 
			expr1 && exprs... --> if expr1 is false, then the whole expression is false 
			expr1 || exprs... --> if expr1 is true, then the whole expression is true 

- Bitwise operator 
	>> 	shift right
	<< 	shift left 
	&	bitwise and 
	|	bitwise or
	^	bitwise xor

- Compound operators:
	lhs op= rhs 
	EQUIVALENT TO 
	lhs = lhs op rhs
	
- Precedence and Associativity:
	Use precedence to determine order between different operators 
	Use associativity to determine order between operators with same precedence
	
- if:
	if (expr) 
	{
		statements...
	}
	else 
	{
		statements...
	}
	Inside the block, variables can be declared
	If can be nested. Else belongs to the closest if. 
	
- Conditional Operator: 
	(expression) ? expr1 : expr2 
	EQUIVALENT TO 
	if (expression) 
		expr1;
	else 
		expr2;

- switch: 
	switch (integer or character or enum) {
		case val1 : 
			stm;
			stm;
			break; // optional 
		case val2 : 
			stm;
			stm;
			break;
		...
		default: 
			stm;
			stm;
	}
	On a match, it starts execute all the code in the switch cases (including also following cases) is executed
	until a break is met. 
	The code for a case require the braces if a var is declared inside it! 
	
- enum:
	enum Color {
		reg, green, blue
	};
	Color screen_color {green};
	switch (screen_color) {
		case red : ... break;
		case green : ... break;
		case blue : ... break;
		default : ...;
	}
	
- for loop:
	for (int i{0}; i < 5; ++i)
	{
		cout << i << endl;
	}
	
	comma operator in for:
		for (int i{1},j{5}; i<=5 ; ++i, ++j)
		{
			cout << i << " * " << j << " : " << i * j << endl;
		}
		
	endless loop
		for(;;)
			cout << "endless" << endl;
			
	vector:
		for(unsigned i{0}; i<vect.size(); ++i)
		{
			...
		}
		unsigned because i is compared with vect.size() which is unsigned 
		
- For Range Based:
	for(auto var : sequence)
	{
		statements with var;
	}
	auto asks the compiler to get the type automatically!
	sequence can be array, vector and also string!
	
- While Loop:
	The condition is checked at the beginning. It may never execute the content of the loop.
	
- Do While Loop:
	do {
		statements;
	} while (expression) 
	used for input validation
	
- Continue & Break: 
	continue : no further statements in the body are executed and it goes to the next iteration 
	break: no further statements in the body are executed and the loop is terminated; 
	
- I/O manipulators:
	#include <iomanip>
	
	cout << fixed << setprecision(decimal digits);
	
- String: 
	array of characters, defined with double quotes 
	"This is a string";
	
- Testing characters:
	isalpha(c) --> true if it is a letter 
	isalnum(c) --> is a letter of digit 
	isdigit(c) --> true if digit 
	islower(c)
	isupper(c)
	isprint(c)
	ispunct(c)....
	
- Conversion functions 
	tolower(c)
	toupper(c)
	if conversion not possible, they return the value given 
	
- C-style Strings 
	Array of characters 
	Terminated by a null character (null).
	c++ is fun 
	stored as 
	c++ is fun\0
	
	char my_name[] {"Mark"}; // allocates space also for \0
	char my_name[8] {"Mark"}; // the extra space is set to \0. my_name[5] = 'y' legal
	char my_name[8]; // uninitalized 
	my_name = "Mark"; ERROR 
	strcpy(my_name, "Mark"); OK 
	
	other operations: copying, concatenation, comparison, searching... 
	
	strcpy(str1, str2); copies str2 into str1
	strcat(str1, str2); concatenates 
	strlen(str); length of str
	
- C++ Strings: 
	#include <string> 
	std namespace
	contiguous in memory
	dynamic size !!!! (like vectors)
	works with input and output streams 
	
		string s1; // initialized to empty string 
		string s2 {"Frank"};
		string s3 {s2};
		string s4 {"Frank", 3}; // Fra
		string s5 {s3, 0, 2}; // from s3 take from 0 2 values, so Fr 
		string s6 (3, 'X');
	
		string s1;
		s1 = "C++ rocks!";
		
		string s2;
		s2 = s1; 
		
		+ for concatenation, but it requires c++ strings or a combination 
			of c++ strings and c strings 
		
		[] or .at() for accessing (at is better, since it performs bounds checking) 

		== != > >= < <= works character by character, and lower case have a higher ascii value than upper case. 
		can compare 2 strings, or one string and a literal/classic c (but no 2 literals /classic c)
		
		object.substr(start_index, length); returns the substring 
		
		object.find(search_string); returns the index of the first occurence of the searched string inside the string 
									returns string::npos if not found inside the string 
									eg. 
									string s1 {"This is a test"};
									cout << s1.find{"This"}; // 0
									cout << s1.find{"X"}; // npos 
									
		object.erase(start_index, length) for erasing a substring 
		object.clear() for cleaning whole 
		
		object.length() for string length 
		
		also for c++ strings, when get from input, the space stops 
		for solving:
			getline(cin, s1); // reads entire line until \n
			getline(cin, s1, 'x'); // reads entire line until \n or x, terminating character 
			
- Functions:
	return_type name (parameter list)
	{
		statements...
		return (return_type obj);
	}
	
	return_type void when nothing is returned
	
	Function must be defined before being used (unless we use function prototypes)
	
	function prototypes: tell the compiler what it needs to know without a full function definition. 
		this is a function declaration. 
		In a function prototype (declaration), we do not need to specify parameters name (they are optional), but the types are mandatory
		
- Function Parameters: 
	Arguments are Passed-By-Value (copied) BY DEFAULT!!!! (quite bad for oop)
		
	Formal Parameters : parameters of the function definition
	Actual Parameters : parameters of the function call 
	
- Default Arguments Values: 
	default values can be in the declaration or definition, but not both! -> PUT IN DECLARATION (best practice)
																			and at the TAIL END of the params list
		eg: 
			double calc (double v1, double v2 = 0.05); // DECLARATION
			double calc (double v1, double v2) { .... }; // DEFINITION, here default values are not expressed 
			
- Function Overloading: 
	different functions with same name, but different parameters (different signature)
	Type of Polymorphism = many forms for the same concept 
	You have to implement all the different overloaded functions! 
	eg:
		int add (int, int);
		double add (double, double);
		...
	N.B.: return type IS NOT CONSIDERED for determining which function to call 
		so, be sure to provide different arguments!
		
	N.N.2: do not mix overloading and default values, it can lead to ambiguous function calls 
	
- Passing Arrays To Cpp Functions 
	void print_array(int numbers []); 	EQUIVALENT to void print_array(int* numbers);
	We are passing the address of the first element of the array 
	We must also provide the array size to! 
	void print_array(int numbers [], size_t size); 
	
	This is PassByValue of the address of the first element of the array -> we can edit the original array from the called function 
	To avoid side effects by a function call use const:
		void print_array(const int numbers[], size_t size);
		This way the memory area of the array becomes read-only
		const before a pointer makes the whole area pointed not writable 
		
- PassByReference: 
	Used to modify the actual parameter from inside the function 
	
	void f(int& num); 
		now num is an alias for the actual parameter when the function is called;
	eg:
		void swap(int &a, int &b)
		{
			int temp = a;
			a = b; b = a;
		}
		the call is 
		swap(x,y);
		
	PassByReference us useful in order to avoid PassByValue of big objects with function calls.
	
	But it makes the function able to change the data passed. 
	If one want to avoid it:
	
	PassByReferenceConst
	
		void print_vector(const vector<string>& v){     }
			inside the function I can access v, but not edit it
			v.at(0) = "Ciao"; // ERROR!
		
- Scope Rules:
	Local and Global scope 
	Function cannot see variables of the caller. 
	
	static type name {..}; // Value is preserved during whole program lifetime 
	A static variable lives between function calls and code block -> like a global variable
	
	
	global variables are variables declared outside functions. 
	Best practice: use only for constants 
	
	It tries to use the variable with the given name, declared in the closest scope. 
	
- Function Calls:
	uses a stack LIFO (last in first out). 
	Activation Record = place on the stack used for activating the function, passing parameters 
					and return address
	See lecture 111 from udemy course 
	
	main has it's variables on the stack. 
	When it call a functions, it pushes on the stack the parameters values and a space for the result 
	Then the function does its work (eventually calling another function etc...). 
	When it ends, it deletes its variables from the stack, and passes the eventual result. 
	Note that if a parameter is passed by reference, when the reference is edited, the actual parameter changes. (like a pointer with already the * in front). 
	
- Inline Functions: 
	Function calls have a certain amount of overhead. 
	For easy and simple functions, it's better to declare them inline -> the assembly code for the function it's put directly, avoiding all the jumps 
	in the machine code. 
	
	inline int add_numbers(int a, int b) // definition 
	{
		return a + b;
	}
	
	Now the compilers make simple functions inline by default. 
	
- Pointer:
	A pointer is a variable that stores the address of another variable 
	
	They works really well with arrays 
	Used to allocate dynamically memory 
	Used to implement polymorphism 
	
		var_type* var_name {nullptr}; 
		eg:	int* int_ptr {nullptr};
	
	ALWAYS INITIALIZE A POINTER BEFORE USAGE, otherwise garbage data 
	Initialize to nullptr (0), this way they point nowhere (and raises null pointer exceptions). 
	
	To initialize a pointer you can use the address operator & (do not confuse with the reference operator, always &, but used after var type). 
		int num {10};
		int* p {&num};
	
	n.w. also pointers have an address, so &p is the address where we store the pointer to num. 
	n.w. pointers can change after been initialized, reference can only be initialized!
	
	All pointers have the same size, like 4 bytes. Use sizeof(p);
	
	The compiler checks that the thing pointer by the pointer has the corret declared type:
		int num {10};
		int* p {&num};
		double num2 {100.2};
		p = &num2; // ERROR, p is a pointer to an int, not a double 
		
	Derefencing a Pointer = access the data the pointer is pointing
		int score {100};
		int* p_score {&score};
		cout << *p_score << endl; // 100
		*p_score = 200; 
		cout << *p_score << endl; // 200 
		
		string name {"Mark"};
		string* p_name {&name};
		cout << *p_name << endl; // Mark

	Pointers issues:
		- Memory Leaks: This occurs when memory is repeatedly allocated by a program but never freed. This leads to excessive memory consumption and eventually leads to a system crash. 
		- Dangling Pointers: A dangling pointer is a pointer that occurs at the time when the object is de-allocated from memory without modifying the value of the pointer.
		- Wild Pointers: Wild pointers are pointers that are declared and allocated memory but the pointer is never initialized to point to any valid object or address.
		- Data Inconsistency: Data inconsistency occurs when some data is stored in memory but is not updated in a consistent manner.
		- Buffer Overflow: When a pointer is used to write data to a memory address that is outside of the allocated memory block. This leads to the corruption of data which can be exploited by malicious attackers.
		
- Constant and Pointers:
	- pointer to constants: data pointed by the pointer is constant, but the pointer can change 
		int score {100};
		int other_score {200};
		const int* score_ptr {&score}; // ptr is a pointer to a constant int  
		*score_ptr = 9; // ERROR
		score_ptr = &other_score; // ok 
	
	- constant pointer: the pointer is constant, so it cannot point to anything else (good if I don't want to lose the reference to some memory)
		int score {100};
		int other_score {200};
		int* const score_ptr {&score}; 
		*score_ptr = 9; // ok
		score_ptr = &other_score; // ERROR 
	
	- constant pointer to constants: the data pointed is constant, and also the pointer cannot point to anything else 
		int score {100};
		int other_score {200};
		const int* const score_ptr {&score}; 
		*score_ptr = 9; // ERROR
		score_ptr = &other_score; // ERROR 
		
	- constant reference (bonus):
		int num{100};
		const int& ref {num}; // ref now is an alias for num, and cannot change num value
		n.w.: const int& ref AND int const& ref 	are the same, but the first is more readable 
		
			recap: 
				const int* const ptr {&num}; // constant pointer whose value pointed cannot be changed
				const int& ref {num}; // reference whose value pointed cannot be changed. Note that reference 
										// are constant by design, they cannot change the obj they are refering 
						
- Passing Pointer to a Function: 
		void double_data(int* int_ptr);
		void double_data(int* int_ptr)
		{
			*int_ptr *= 2;
		}
		
		call: 
		int value{10};
		double_data(&value); 
	
- Return a pointer from a function: 
		int* largest_int (int* ptr1, int* ptr2)
		{
			....
			return ptr1; (or ptr2)
		}
		
		usage: 
		int* largest_ptr = largest_int(&a, &b); 
		
		We can also allocate memory inside the function, with new, and return a pointer to the newly allocated memory 
		(for example a data constructor...) 
		remember to deallocate the memory, when it is not needed. 
		
		DO NOT: 
			- return address of local variable of a function! (they are deleted once the function ends);
			- return a pointer created inside the function, still deleted when the function ends;
		
- Dynamic Memory Allocation: 
	All memory allocated for a pointer is from the heap. 
	Heap is the memory used for dynamic memory allocation (while stack is used for function variables and activation frames).
	
		int* int_p {nullptr};
		int_p = new int; // DYNAMIC MEMORY ALLOCATION 
		
		count << int_p << endl; // Address from the heap 
		cout << * int_p << endl; // Garbage data 
		*int_p = 100; // Initialization 
		cout << *int_p << endl; // 100
		
		delete int_p; // MEMORY DE-ALLOCATION
	
	If you lost reference to the memory created with the new  keyword, you have a MEMORY LEAK!

	with an array: 
		
		int* array_p {nullptr};
		int size {10};
		array_p = new int[size];
		...
		delete [] array_p;
		
- Pointers Pitfalls:
	- uninitialized pointer 
	- dangling pointer: 2 pointers point the same data, one releases, the other remains dangling 
	- pointer that points to invalid memory 
	- not checking if new failed (we will see with exception handling) 
		int* p = new int; 
		if(p != nullptr) {....} 
	- forget to deallocate memory, or change pointer pointed data and then have a memory leak 
		
- Relationship between arrays and pointers: 
	Pointer and Array name are the same, they both points to a memory location (only difference is that array name cannot be changed). 
	
		int scores[] {100, 95, 80};
		cout << *scores << endl; // 100
		cout << *(scores + 1) << endl; // 95 -> goes to the next element, it's increased by int size 
		cout << scores[0] << endl; // 100 
		
		int* score_ptr {scores};
		cout << score_ptr[0] << endl; // 100 
		cout << score_ptr[1] << endl; // 95 
		... 
	
	so: 
		int arr [] {1,2,3,4,5};
		int* ptr_name {arr};
		
		arr[index];
		ptr_name[index];
		
		*(arr + index);
		*(ptr_name + index);
		
- Pointer Arithmetic: 
	Pointer arithmetic makes sense only with raw ARRAYS! 
		
		int_ptr++ --> increments a pointer to point to the next array element
		int_ptr-- --> previous element 
		
		int_ptr += n --> points n elements further 
		int_ptr -= n 
		
		ptr1 - ptr2 --> difference in position from the pointed 2 elements (must be of the same type)
		
		ptr1 == ptr2 iff they point to the same location (this does not check value at the location) 
		*ptr1 == *ptr2 iff the pointers points to two same element 
		
- References: 
	Reference is an alias for a variable
	Must be initialized to a variable when declared 
	Cannot be null and cannot refer another variable 
	Useful as function parameters 
	Like a "constant pointer, automatically dereferenced" (type* const p)
	
		int num{100};
		int &ref {num};
		
		vector<string> names {"mark",...};
		for(auto &str : names)
		{
			do something with str, even change it 
			this is the best practice, does not create a copy of each element of the vector 
		}
		for(const auto& str : names)
		{
			this version with const is useful when you don't want to change the values inside names 
		}
	
	They are also useful for changin collections content with for each loop: BEST PRACTICE!!
		for(auto& str : names) {  str = "pluto"   } // all names change to pluto 
		for(const auto& str : names) {...} // here we avoid str to be changed 

- RValue & LValues: 
	- lvalue: value that has a name and is addressable (and modifiable if not constant) 
		eg:
		int x {100}; // x is LVAL
		x = 1000;
		string name; // name is LVAL
		name = "Frank";
		
		100 = x; // ERROR, 100 NOT an LVAL 
		"Frank" = name; // ERROR; "Frank" NOT a LVAL 
		
	- rvalue: everything that it is not an lval:
		- on the right of the assignment 
		- a literal 
		- a temporary which is intended to be non modifiable
		
		eg: 
		int x {100}; // 100 is a RVAL
		
		rval can be assigned to lval: 
		x = 100;
		x = x+y;
	
	- lval reference: 
		The reference used so far are lval references, because they reference l-values 
		eg: 
		int x {100}; // x is a lval 
		int& ref1 = x; // ref1 is an lval 
		ref1 = 150;
		int& ref2 {5}; // ERROR, ref2 is an lval ref and cannot reference an rval 
		
- Debugger: 
	Click the debug button 
	Step goes to next code line, f10
	Step into goes to the next function call, f11
	
	The content table may need to be refreshed when we work with pointers 
	
- Pointers vs References:
	- PassByValue: 
		use this when passing only small parameters, like int 
	
	- PassByReference with Pointer: 
		use this when the function DOES modify the actual parameter, 
		and the parameter is expensive to copy
		and OK for the pointer to contain nullptr value (useful for some data, like lists and trees).
		
	- PassByReference with Pointer to const: 
		as before, but the function DOES NOT modify the actual parameter 
		
	- PassByReference with Reference 
		use this when the function modifies the actual parameter, 
		and the parameter is expensive to copy,
		and the parameter will never be nullptr
	
	- PassByReference with Reference to const: 
		as before, but the function DOES NOT modify the actual parameter

- OOP vs Procedural Programming: 
	In procedural programming the focus is on actions that a program takes 
	But as the program gets larger, it begins to explode 
	
	Object Oriented: modelling project in classes and objects 
	
	Allows abstraction. 
	
	Encapsulation: objects contain data AND operations that work on that data 
		--> Abstract Data Type 
		
	Information Hiding: hide implementation-specific logic, and expose only
		interfaces 
		
	Reusability: easier to reuse classes in other applications
	
	Inheritance: can create new classes in term of existing classes 
		--> polymorphic classes. 
		
	Limitation: does not make code better automatically, difficult to learn 
		more up-front design is necessary to create good models&hierarchies
		larger programs 
		
- Classes & Objects: 
	Class: 
		user defined type 
		blueprint from which objects are created
		has attributes 
		has methods 
		can hide data and methods 
		provide a public interface
		
	Object: 
		created from a class 
		represent a specific instance of a class 
		we can create many, many objects 
		each has its own identity (attributes=Ã¬)
		each can use the defined class methods 
		
	Account account1; 
	Account = class 
	account1 = object from class Account 
	
- Class Declaration & Object Creation 
	Class Declaration: 
		class Class_Name
		{
			// declarations..
		}
		eg: 
		class Player // uppercase 
		{
			std::string name;
			int health;
			int xp;
			
			void talk(std::string text_to_say){ ... }
		}
	
	Object Creation: 
		Player frank;
		Player hero; 
		// Here we create a pointer to an object of type Player 
		// and we create one, by instantiating the memory 
		Player* enemy = new Player(); 
		...
		// Remember to free up memory when not neede! 
		delete enemy;
		
	We can create array or vector of objects! 
	
- Access Class Members 
	Some class members will not be accessible!
	
	If we have an object -> dot operator
		Account frank_account;
		frank_account.balance;
		frank_account.deposit(1000.0);
		
	If we have a pointer to an object -> dereference and then dot OR arrow
		Account* frank_account = new Account;
		(*frank_account).balance; 
			or equivalently 
		frank_account->balance; 
		
- Public, Private, Protected:
	- Public: accessible everywhere 
		class Class_Name
		{
		public: 
			// everything here is public, until next tag
		}
	- Private: accessible only by class members or class friends
		class Class_Name
		{
		private: 
			// everything here is private, until next tag
		}
	- Protected: used by class and inheriting classes 
		class Class_Name
		{
		protected: 
			// everything here is protected, until next tag
		}
		
	Accessing private class member from outside leads to a Compiler Error.
	
- Implementing Member Methods: 
	Can be implemented inside the class declaration
		implicitly inline 
	Can be implemented outside the class declaration 
		need to use Class_Name::method_name
	Can separate definition from declaration 
		.h for the declarations 
		.cpp for definitions (implementation) 
		then include it with #include 
		
		If included multiple times, it can be read from the compiler multiple 
		times. In order to avoid multiple classes with same same, use the 
		include guards (preprocessors code)
			#ifndef _ACCOUNT_H_
			#define _ACCOUNT_H_
			class Account {
				...
			}
			#endif
			
			or 
			
			#pragma once // do the same as the 2 before
				// easier I suppose
			
		In the specification file: 
			#include "Account.h" // here we specific the position of the header file
			
			void Account::set_balance(....){....}
			...
	
		Then when used:
			#include "Account.h"
			
			int main()
			{
				Account a; 
				...
			}
	
- Constructors & Deconstructors:
	Constructor: 
		used for creating an object of a specific class
		No return type 
		Same name of the class 
		Can be overloaded!
		
	Destructor: 
		tilde+class name 
		no return type and no parameters 
		cannot be overloaded 
		invoked automatically when an object is destroyed 
			- if it is a local variable, when the execution goes out of scope
			- if it is pointer by a pointer, when delete is called
			
- Default Constructor: 
	Does not expect any argument, used by default if not other constructor defined 
	Called when object created, or memory with new allocated. 
	
	If we define no constructors, then the default constructor is automatically added
	If we define a constructor with no parameter, we are overloading the default constructor 
	If we define a constructor with parameters, then the default constructor is not automatically added (if you need it, add it)
	
- Overloading Constructors:
	We can have multiple constructors, overloaded. 
	When we create at least one constructor, the default is not automatically added anymore. 
	
- Constructor Initialization List: 
	more efficient
	Initialization list follows parameter list 
	initializes data members as the object is created, 
		while previously we did an assignment. 
	initialization is better than assignment! 
	
	Constructor_Name : var1{value1}, var2{value2}...
	
- Delegating Constructors: 
	Often code for constructors is very similar 
	-> delegate constructors:
		code for one constructor can call another in the initialization list 
		avoids duplicating code
		
	Delegate to the constructor that has more parameters 
	
	Note that when a constructor delegates to another constructor, it executes the called 
	constructor (also its body), and then goes back and does the body of the calling constructor
	
- Default Constructor Parameters:
	Used to avoid multiple constructor overloading 
	(default parameters are specified only in the declaration - header file)
	Note that if you have a constructor with no args, and one with all params specified, then you 
		get a compiler error, since it does not know which one to call! 
		
- Copy Constructor: (by default, shallow copy = memberwise copy) 
	Constructor that creates an object from another existing object
	
	- It is called when an object is passed by value as a parameter of a function 
	- It is also called when an object is returned from a function (because the one created 
		in the function is destroyed, since it was placed on the stack. 
		to avoid this, pass references or pointers!)
	- It is called when we create an object from an existing one 
		Player another_player {player};
		
	The Default Copy Constructor performs member wise copy BUT 
		if you are using pointers, they will be copied, but not what they are pointing to 
		
	Provide a user defined Copy Constructor if you are using raw pointer members 
	
	Provide the copy constructor with a const reference parameter 
	
	Use STL classes as they already provide copy constructors 
	
	Avoid using raw pointer data members if possible 
	
	eg:
		Type::Type(const Type& source); 
			// We are copying source.
			// const is needed because we don't want to change source 
			// the reference is needed because we don't want to pass source by value 
			// and trigger an infinite copy constructor call!!!
			
		Player::Player(const Player& source) : 
			name {source.name},
			health {source.health},
			xp {source.xp}
			
	N.w.: if a class has a pointer as a member, as best practices we must: 
		- allocate memory for that pointer in the constructor 
		- free memory for that pointer in the destructor
		
	Now suppose that the object to be copied has a pointer in it. 
	We can have 2 behaviors when copying that object: 
		- Shallow Copy: 
			memberwise copy -> both objects pointers pointing to the same area in the heap 
			PROBLEM: when one of the 2 is destroyed, it also release memory from the heap for its pointer 
				-> the other still points to the released storage -> PROGRAM CRASH
				
		- Deep Copy: 
			memberwise copy for non pointers 
			for pointers, copy what the pointer is pointing to (not just where it's pointing). 
				-> each object pointer points to different memory location, but both containing the same data 
				
- Move Constructor: (rval references)
	lval if has a name of addressable, rval everything else 
	In move semantics, rval are temporary objects created by the compiler 
	and objects returned from functions call
	
	int total{0};
	total = 100 + 200; 
		100+200 evaluated and stored in a temp val, then assigned to total, then temp destroyed 
		
	move semantics addresses rvalues
	
	When an object is created unnamed (when it is passed as a function parameter)
		-> it is an rval
		We can pass it directly to the function, instead of using a copy of it 
		We need a Move constructor, that moves that temporary object to an actual object.
	
	Copy constructors can be called many times automatically -> large overhead if deep copying involved
	Solution is to use 
	Move constructors, which move objects rathen than copying them 
	(note: copy elision may optimize copying away completely) 
	
							int x{100}; // x is an l_val
							
	lval references & 		int &l_ref = x; // classic reference seen up to now
							l_ref = 10;
							
	rval references && 		int &&r_ref = 200; // 200 is an rval. 
											// r_ref is a rval ref to 200
							r_ref = 300; // here we change the temporary value 
										// that has 200 in it, to 300
										
							int &&r_ref = x; // compiler error, 
										// we are trying to store in an rval ref
										// an lval
										
							void f1 (int& n) {...}
							void f2 (int&& n) {...}
							
							f1(x) OK
							f1(200) ERROR 
							f2(x) ERROR 
							f2(200) OK 
							
	When an object is passed as a parameter, copy constructor is invoked:
		fun(obj);
			a copy of obj is created, using the copy constructor 
			we hence have an unnamed object, so an rval, that needed a deep copy in order to be created 
	This may lead to a lot of inneficient deep copies. 
	
	Move constructor signature: 
		Type::Type(Type&& source); 	// source is an rval ref
	
	The implementation requires to copy from source all the pointers, and 
	null out the pointers in source 
	(eg. with move class)
		
		Move::Move (Move&& source) 
		: data{source.data} {
			source.data = nullptr; // this is the main difference from the shallow copy 
		}
	
	Steal the data and then null out the source pointer 
	
	Copy constructors do their job by doing deep copies, receiving lval ref
		They are needed when we want a copy of an lval 
		
	Move constructors takes the rval ref, and use them to create a new object 
		by doing a shallow copy.
		A shallow copy is enough, because nobody will use the temporary object created 
		It is just enough to null out every references in the original temporary object 
		This way we avoid a deep copy of something that originally is not needed anymore 
		(so there are no pointers pointing to released storages, and also there are not double memory instantiation)
		
- This Pointer:
	Contains the address of the objects (it's a pointer to the object)
	Can only be used in class scope 
	Used to:
		access data member and methods 
		determine if 2 objects are the same 
		access to current object (*this)
		
	It also solves abigous parameters names 
	
- Const with Classes: 
	We can create const objects 
	const object -> we cannot change it 
	
	In order to be able to call functions on const object, add const to those functions 
	
- Static Class Members: 
	Members or functions that belongs to the class, not a specific object.
	-> class wide information.
	
	Static functions have access to only static members
	
- Struct vs Objects: 
	In structs, the members are all "public" by default
	Use structs when you have passive data (no methods)
	
- Friends of a class:
	Friend of a class is a function or another class that has access 
	to the class private Members (functions and variables). 
	Break of encapsulation...
	
	Properties: 
		- Friendship must be granted, not taken 
		- Friendship is not symmetric 
		- Friendship is not transitive 
		
		class Player {
			friend void function(...); // not function cann access Player private Memebers
			friend void Other_class::function(...); // function from Other_class can access Player private members
			friend class Other_class; // Other_class can access Player private Memebers
		...
		}

	eg: 
		#include <iostream>
		using namespace std;
		
		class GFG {
		private:
			int private_variable;
		
		protected:
			int protected_variable;
		
		public:
			GFG()
			{
				private_variable = 10;
				protected_variable = 99;
			}
		
			// friend class declaration
			friend class F;
		};
		
		// Here, class F is declared as a
		// friend inside class GFG. Therefore,
		// F is a friend of class GFG. Class F
		// can access the private members of
		// class GFG.
		class F {
		public:
			void display(GFG& t)
			{
				cout << "The value of Private Variable = "
					<< t.private_variable << endl;
				cout << "The value of Protected Variable = "
					<< t.protected_variable;
			}
		};
		
		// Driver code
		int main()
		{
			GFG g;
			F fri;
			fri.display(g);
			return 0;
		}
		
- Operator Overloading: 
	Use traditional operators such as +, =, * etc... 
	Allow user defined types to behave like built in types. 
	
	Syntactic sugar 
	
	Precedence and associativity of the overloaded operator cannot be changed 
	Same applies for arity. 
	
- Overloading Copy Assignment operator: 
	(especially used when we have a lval on the rhs of = operator) 
	N.w.:
		Mystring s1 {"Frank"};
		Mystring s2 = s1; // initialization, not assignment!! same as s2 {s1}
		s2 = s1 // assignment 
	
	By default, = is automatically provided with shallow copy. 
	If we have raw pointer data, we must do deep copy.
	
	Overloading = operator: 
	
		Type& Type::operator= (const Type& rhs);
	
	we can now do
		
		s2 = s1; OR s2.operator=(s1);
		
	With MyString class: 
		
		Mystring& Mystring::operator=(const Mystring& rhs)
		{
			if(this == &rhs) // check for self assignemnt 
				return *this;
			
			delete [] str; // deallocate storage for this->str 
			str = new char [std::strlen(rhs.str) + 1]; // allocate storage for rhs.str
			std::strcpy(str, rhs.str); // copy content 
			
			return *this; // return current object, to support chain assignment 
		}
		
- Olverloading move assignment operator: 
	Used when we have a rval in the rhs of = operator 

		Mystring s1;
		s1 = Mystring {"Frank"};
		
	If no move assignment provided, c++ uses copy assignment.
	But actually we can move the rval Mystring{"Frank"}, and use it for s1, 
	avoiding deep copy. 
								// no const before Type&& since we will edit rhs by nulling out its pointers 
		Type& Type::operator= (Type&& rhs); // rval reference 
		
		s1 = Mystring{"Joe"};
		s1 = "Frank";         //in both cases move assignemnt called 
		
	With Mystring class: 
		
		Mystring& Mystring::operator= (Mystring&& rhs)
		{
			if (this == &rhs) // self assignemnt
				return *this;
			
			delete [] str; // clean up str in this->str; 
			str = rhs.str; // copy pointer from rhs 
			
			rhs.str = nullptr; // null out pointer in rhs 
			
			return *this; // return for chain assignemnt 
		}
	
	n.w. 
		given 
			Mystring s1 {"Hi"}; // created with one arg constructor
		copy constructor called with 
			Mystring s2 {s1} 
		move constructor called with 
			Mystring s2 {Mystring{"Hola"}}
		copy assignemnt called with 
			s2 = s1;
		move assignemnt called with 
			s2 = Mystring{"Paola"};
			
- Operator Overloading using Class Member Methods:
	We can overload -, ++, --, ! operators... 
	
	In general: 
		an operator whose result is a new value, must return by value (invoke copy constructor on returned object) 
		an operator whose result is an existing value, must return by reference (object is on the heap) 
		
- Operator Overloading using Global Functions: 
	We do not have the "this" pointer -> declare them as friend, and pass as argument the reference to this 
		(declare as a friend in order to make it able to access class private fields)
	
		ReturnType operatorOp(Type& obj); 
		eg
		Mystring operator-(const Mystring& obj); // obj is a reference to the object we want to apply - on 
		
	The main advantage is that we can call the operators on one or both arguments that can be converted to our obj type using one of the provided constructors 
		
		Mystring names {"Marco, Anna, Laura"};
		Mystring result;
		result = "Hi" + names; 
		
- Stream Insertion and Extraction operators overloading: 
	They are overloaded as non member function 
	
		std::ostream& operator<<(std::ostream& os, const Mystring& obj)
		{
			os << obj.str;
			return os; // chain extraction  
		}
		
		std::istream& operator>>(std::istream& is, Mystring& obj) // obj is not const, since we may edit it 
		{
			char* buff = new char[1000];
			is >> buff;
			obj = Mystring{buff};
			delete [] buff;
			return obj; // chain insertion, copy constructor called 
		}
	
- Inheritance: 
	Allow for reuse of existing class 
	Inherit from parent class, and also tweak the imported methods (overriding). 
	The base class has its attributes and methods 
	A derived class can have other attributes, and can override base class methods 
	
	Inheritance = creating new classes from existing classes 
	Single Inheritance = create new class from another single class 
	Multiple Inheritance = create new class from 2 or more other classes 
	
	Base/Parent/Super class 
	Derived/Child/Sub class 
	
	Is-A Relationship from derived to base class 
	
	Generalization -> combining similar classes into a single one 
	Specialization -> creating new classes from an existing one, providing specialization 
	
	Inheritance or Class Hierarchies 
	
	Inheritance is transitive 
	
- Inheritance vs Composition: 
	Inheritance "is-a" relationship: 
		Employee is-a person
	Composition "has-a" relationship: (achieved via memebr of other object type) 
		Person has-a account 
		Player has-a special attack 
		Circle has-a location
	
	If composition is possible, it is better to try with that first, as it is easier to manage

- How to Inherit: 
		class Base { ... }
		
		class Derived : access-specifier Base { ... } 
	
	access-specifier can be: 
		- public: 
			establish a "is-a" relationship between derived and base classes 
			Public and Protected members of the parent class remains Public and Protected members of the inheriting class 

		- private and protected: 
			establish "derived class has a base class" relationship ("is implemented in terms of" relationship, like vector is implemented in terms of array)
			(we are hiding from outside the derivation) 

			Public and Protected members of the parent class becomes [private] or [protected] members of the inheriting class.
			(private or protected according to the type of inheritance)
			Private members are still not accessible in the derived class!

			In this way, the inherited properties are not accessible from outside 

- Protected class Memebers: 
	Memebers accessible from the class itself, and from classes derived from base class 
	Private (inaccessible) from the outside 
	
- Constructors and Destructors with Inheritance 
	When a derived object is created: 
		first base class constructor executes 
		then derived class constructor executes 
		
	When a derived object is destructed: 
		first derived class destructor executes 
		then base class destructor executes 
			Each destructor is responsible to free the resources allocated in the corresponding part of the object

	A derived class DOES NOT inherit: 
		base class constructor
		base class destructor
		base class overloaded assignment
		base class friend functions 
	However, the derived class constructors, destructors and overloaded assignment operations can invoke base class versions

	But default base class constructors are called from derived class constructor AUTOMATICALLY!
	If you want to specify which one to call, do it EXPLICITLY 
	
	A derived class constructor, destructor and overloaded assignment can invoke base class version: Base::Base

	If no explicit base class constructor called, the one without any args is chosen 
		Default policy!

	Generally it is better to declare explicitly which constructor from the base class to call! 	

- Invoke base class constructors:
	The base part of a derived class must be initialized first, then the new part. 
	
		public Base { 
		public: 
			Base(int);
			...
		}
		
		public Derived : public Base {
		public:
			Derived(int);
		}
		
		in cpp of Derived class:
		
		Derived::Derived(int x) 
			: Base(x), {optional initializers for Derived} // call to constructor of base class that takes 1 method
		{
			...
		}
		
	This way we have complete control over which constructor is called for the base class. 
	remember: 
				FIRST base constructor THEN derived constructor.
				FIRST derived constructor THEN base destructor 
				
- Copy/Move constructors and overloaded =
	These are not inherited from the base class
	You may or may not need them (provide them when you use raw pointers) 
	
	Copy constructor: (also applies to Move Constructor)
		We must invoke the base class copy constructor explicitly
													// here other is sliced from Derived to Base type 
													// other type is Derived -> is also a Base
		Derived :: Derived(const Derived& other) : Base(other), {Derived initialization list} 
		{
			// code 
		}

		Slicing is the process that takes only a part of a class, happens when a reference of a pointer of a higher type is used to refer an object of a derived type
			Only the part that the base type knows can be accessed
	
	Copy assignment: 
		We must invoke the base copy assignment operator as first part of the derived copy assignment (after checking for self assignment!)

	Summary for inherited Copy/Move constructor and Copy/Move assignment operator
		If you DO NOT define them in the Derived class -> the compiler will define them automatically and invoke the base versions 
		If you DO define them in the Derived class -> you must explicitly invoke the base versions 
			You must define them if you have raw pointers -> deep copy or move 

- Redefining base class methods 
	Dervied class can override or redefine Base class methods -> just use the same signature. 
		We can also call the base class version by specifyng the base class type and the method name (eg Account::deposit(amount))
	
	Static binding determines which method to call at compile time, based on the type of the object it finds.
		Very efficient, but sometimes we need to bind (override) at runtime -> that will involve polymorphism

	c++ by default uses static binding -> call the method specified in the type of the object/reference/pointer

- Polymorphism
	Two types of Polymorphism: 
		Compile Time (early binding, static binding): Function and Operator Overloading 
			Default in c++
		Run Time (late binding, dynamic binding): Function Overriding
			Not default, achieved via: 
				Inheritance 
				Base class pointers of references 
				Virtual functions
		
	If we have (no virtual and overriding)
		Account* p = new Trust(); // where Trust inherits from Account 
		p->withdraw(1000); // calls the withdraw method of class Account, since static binding is applied by default
		// if we enable run time polymorphism
		p->withdraw(1000); // this will call the withdraw method of class Trust, if the method is overridden

- Base class Pointer Requirement for Polymorphism
	Account* p1 = new Account();
	p1->withdraw(1000); // call Account withdraw
	Account* p2 = new Savings();
	p2->withdraw(1000); // call Savings withdraw
	Account* p3 = new Checking();
	p3->withdraw(1000); // call Checking withdraw
	Account* p4 = new Trust();	
	p4->withdraw(1000); // call Trust withdraw

	vector<Account*> accounts {p1, p2, p3, p4};
	for(auto acc_ptr : accounts)
	{
		acc_ptr->withdraw(1000); // each time calls the specific withdraw method 
	}

- Virtual Functions vs Redefined Function 
	Redefined functions are bound statically 
	Virtual functions are bound dynamically 

	In the base class: 
		virtual void withdraw(double amount);
	In the derived class: 
		virtual void withdraw(double amount);
			Here the virtual specifier is not mandatory, the method withdraw will be overridden in the derived class
			but it helps recognize that the function will be dinamically bounded

- Virtual destructors
	If a derived class is destroyed via a base class pointer, the behavior is undefined -> we must provide virtual destructors too 
		We may have memory leaks
	If a class ha virtual function -> ALWAYS PROVIDE A PUBLIC VIRTUAL DESTRUCTOR
		With this, the correct destructor is invoked, which in turns will also call destructors of the parent class (in the order specified by the class hierarchy)

- Override specifier 
	Up to now, to perform dynamic bound, we must have the same signature
	To make sure the compiler check that we are actually creating a dynamic bound method, we can add the override specifier. 
	It tells the compiler that the method X is overriding the method X in the base class .
	without is, if we make any unwanted changes when specifying X, the compiler will treat it as a new method, not an overriding one. 

	Remember: also const is part of the function signature! 

	If we add the override specifier, but the compiler finds no matching methods -> compiler error 

- Final specifier 
	Can be used at: 
		Class Level -> to prevent a class from being derived from 
		Method Level -> prevents virtual method from being overridden in derived classes 

- Base class references 
	We can also use base class references with dynamic polymorphism

- Pure virtual functions and Abstract Classes
	Abastract Class: class that cannot be instantiated 
	Concrete Class: class that can be instantiated

	To have an Abstract Class in cpp we need at least one Pure Virtual Function
		virtual voit func(..) = 0; // =0 tells the compiler that this function is Pure -> the class cannot be instantiated
									// typically pure virtual functions don't have any implementation, but it is possible to have it
	
	If the Derived class does not override the pure virtual functions of the Base class, Derived is still Abstract
	If we add a pure virtual function to a class, it becomes an Abstract Class! (so we may have abstract classes inheriting from concrete classes too!)

	Given Shape abstract and Circle concrete: 
		Shape shape; // ERROR 
		Shape* ptr = new Shape(); // ERROR 
		Shape* ptr = new Circle(); // fine 
		ptr->draw(); // fine 
		ptr->rotate(); // fine 

- Abstract class as an Interface 
	An Interface is an Abstract Class with ONLY pure virtual function, no implementation!
	Each class implementing an interface, to be instantiated, must implement all the methods (pure virtual) defined in the interface
	

- Lambdas Cpp
	Part 1: https://medium.com/factset/modern-c-in-depth-lambdas-part-1-d03fe8153ee1
	Part 2: https://medium.com/factset/modern-c-in-depth-lambdas-part-2-a2d54c7b51
	Part 3: https://medium.com/factset/modern-c-in-depth-lambdas-part-3-561823a990e6

	- Example of a lambda function usage 
		Eg: 
		void lambda_demo(std::vector<std::string>& tickers)
		{
			const auto& cache = get_cache();

			std::sort(std::begin(tickers), std::end(tickers),
				[&cache](const std::string& lhs, const std::string& rhs) {
				return cache.get_opening_price(lhs) <
					cache.get_opening_price(rhs);
				});
		}

	- Most lambda expressions will have three parts: 
		a capture list 			[...]
		a parameter list		(...)
		and a function body		{...}
	
	- To store lambda in a variable -> use auto 
		Since each lambda will be converted to a compiler generated class, whose name is unknown before compilation, thus use auto
		Eg:
		const auto lambda = [&cache](const std::string& lhs, const std::string& rhs) {
			return cache.get_opening_price(lhs) < cache.get_opening_price(rhs);
		};

		std::sort(std::begin(tickers), std::end(tickers), lambda);
	
	- Capturing variables: 
		- By Reference 
			[&cache] -> variable cache is captured by reference -> lambda has a reference to cache
		- By Value
			[date] -> date is captured by value -> it will be copied inside the lambda context 
				This can be problematic if the variable is bit -> lot of time lost on copying
		- By default reference [&]
			As of by reference, but captures automatically all the variables referenced inside the lamabda from outside
		- By default copy [=]
			As of by copy, but captures automatically all the variables used inside the lambda from outside
		- Capturing move only type 
			Used to capture a move-only resource into a closure, using the copy-initialization syntax: 
			[cache = std::move(ticker_cacke)]... -> move makes ticker_cache a rval reference, ready to be moved by move constructor into cache

		- Problems: 
			- When capturing by reference and the variable referenced goes out of scope -> program crashes 
				Simplest solution is to avoid having references to variables local to the lambda function. Otherwise, a Capture by Value may solve, however...
			- When capturing by value, caputiring a variable of a class, it is actually storing the value of pointer this (*this), thus if the object that creates the lambda is deleted, then the this pointer will have undefined behavior 
			- Generally, try to capture explicitly the variables you need, and if available, use capture move only type.
				auto get_functor()
				{
					return [copy = m_data](){ std::cout << copy << std::endl; };
				}

		- Lambda type: std::function<>
			Lambdas type can be specified via
				std::function<ReturnType(ParamType1, ParamType2, ...)>

			Eg:
			// Lambda that returns a std::string::size_type, and takes two inputs of type const std::string&
			const std::function<std::string::size_type (const std::string&, const std::string&)> fn =
				[](const std::string& lhs, const std::string& rhs) {
					return lhs.size() + rhs.size();  // Returns a `std::string::size_type`
				};

- Cast to void*
	In C++, casting to void* means converting a pointer of any type to a generic pointer type void*. The void* type is a special pointer type that can point to any data type, but it does not know the type of the object it points to. This makes void* useful for generic programming and for functions that need to work with different data types without knowing their specifics.
		int* ptr {nullptr}; // pointer to int 
		void* voidPtr = (void*) ptr; // we are pointing to the same memory address, but we dont' know anymore the type 

- Concurrent programming in cpp 11
	https://youtube.com/playlist?list=PL1835A90FC78FF8BE&si=bERFTMuhVVYH4nS8

	New in c++ 11 standard:
		Thread
			Single sequential flow of control within a program. Multiple threads can be used concurrently
		std::mutex
			synchronization primitive used to protect shared data from being used simultaneously 
			A calling thread can own a mutex by locking it, and then unlock 
				-> This may lead to deadlock! 
		Condition Variable 
			Used with std::mutex to notify other threads when a resource is ready to be used 
			Useful in a producer-consumer environment. 
			It's a sort of task completion source.
				condition_variable cv; 

				cv.notify_one(); 
				cv.notify_all();
				cv.wait(...);
				...
		std::atomic 
			One thread can read it, while another read it. Also, may define inter threads synchronization.
		Fence 
			Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses,
		
	Threads 
		The execution of a threads ideally should happen in parallel with the main thread, when started. However, generally it starts a little bit later, thus generally, on simple cases, the synchronization seems to not be necessary. 
		A thread can be created with a lambda as the operation to be performed 

		~ Single thread example
			#include <iostream>
			#include <thread>
			int main()
			{
				std::thread th([]()
				{
					std::cout<<"Hi from thread"<<std::endl;
				});
				std::cout<<"Hi from main"<<std::endl;
				th.join(); // waits for thread th to complete
				return 0;
			}

		~ Multiple thread example 
			We need a barrier, that is something that waits for all the threads to complete 

			#include <iostream>
			#include <thread>
			#include <algorithm>
			int main()
			{
				std::vector<std::thread> workers;
				for(int i {0}; i < 10; ++i)
				{
					workers.push_back(
						std::thread([]()
						{
							std::cout<<"Hi from thread"<<std::endl;
						})
					);
				}
				std::cout<<"Hi from main"<<std::endl;
				// Barrier
				std::for_each(workers.begin(), workers.end(), [](std::thread& th)
				{
					th.join(); // waits for thread th to complete
				});
				return 0;
			}

			In this solution some threads starts before main, others after. This is because there is no synchronization order specified.
		
		~ Closure in Lambda

			#include <iostream>
			#include <thread>
			#include <algorithm>
			int main()
			{
				std::vector<std::thread> workers;
				for(int i {0}; i < 10; ++i)
				{
					workers.push_back(
						std::thread([i]() // capture by value 
						{
							std::cout<<"Hi from thread "<<i<<std::endl;
						})
					);
				}
				std::cout<<"Hi from main"<<std::endl;
				// Barrier
				std::for_each(workers.begin(), workers.end(), [](std::thread& th)
				{
					th.join(); // waits for thread th to complete
				});
				return 0;
			}

			In this case we also see the interleaving between the different threads too!

		~ Move Semantics in Threads 
			Pass by value 
				struct S {}
				void f(S s); // by value 
				S x;
				f(x); // lvalue ok
				f(S()); // rvalue ok
			Pass by Lval reference 
				void f(S& s); // f can modify s
				f(x); // lvalue ok, f can modify it and in the calling context they will see the x changes 
				f(S()); // rvalue NO, it makes no sense to have a rvalue passed to a function that modifies it, since it will be lost after the function execution 
							// this is probably an error made by the programmer, it's a design decision 
				void f(const S& s); // f cannot modify s
				f(x); // lvalue ok, f can modify it and in the calling context they will see the x changes 
				f(S()); // rvalue ok, since it will not modify it, thus it's fine to pass an rvalue type
			Pass by Rval Reference
				void f(S&& s); // f can modify s
				f(x); // lvalue NO, f 
				f(S()); // rvalue yes, it makes sense for f to edit S destructor, and change the way it behaves once the call to f ends, and the destructor of S gets called.

			Copy vs Move: 
				Copy semantics -> copy constructor, assignment operator
					This happens when a copy of an object is performed
					In case of complex data structures, we need to perform a deep copy -> long. If we do not need anymore the original data, we can use move constructor or move assignment, otherwise copy is needed.
				Move semantics -> copy elision for rvalue 
					Useful when the original value is not needed anymore, so we just copy a bunch of pointers and copy a data strcuture at a much lower cost
					Also, it avoids having shared resources when an object is copied, with a shared reference. Try to use it as much as possible, when needed.
		
		~ Move constructor example with threads, without lambda 
			In this example, the threads are created with the parameter i without a lambda, which is a more general use case
			To capture the variable i, we can pass it to the thread constructor 
			Note that here i is copied by value 

			#include <iostream>
			#include <thread>
			#include <algorithm>
			#include <cassert> 

			void thFun(int i)
			{
				std::cout<<"Hi from worker"<<i<<std::endl;
			}

			int main()
			{
				std::vector<std::thread> workers;
				for(int i {0}; i < 10; ++i)
				{
					// first specify the function, then list the parameters
					auto th = std::thread(&thFun, i); 
					workers.push_back(std::move(th)); // rvalue reference used here
					assert(!th.joinable());
				}
				std::cout<<"Hi from main"<<std::endl;
				// Barrier
				std::for_each(workers.begin(), workers.end(), [](std::thread& th)
				{
					assert(th.joinable());
					th.join(); // waits for thread th to complete
				});
				return 0;
			}
		
		~ Demon thread: detatched thread, there is no safe way to terminate them... 

		~ Move constructor example with threads, without lambda and with reference to counter 

			#include <iostream>
			#include <thread>
			#include <algorithm>
			#include <cassert> 

			void thFun(int& i)
			{
				std::cout<<"Hi from worker"<<i<<std::endl;
			}

			void test(std::vector<std::thread>& workers)
			{
				for(int i {0}; i < 10; ++i)
				{
					// first specify the function, then list the parameters
					// Here is is made an lvalue ref, we must tell it explicitly to the compiler
					// However, since we have a reference to i, and the thread may run after test function completion, i can go out of scope -> access of memory which is no more valid
					auto th = std::thread(&thFun, std::ref(i)); 
					workers.push_back(std::move(th)); // rvalue reference used here
					assert(!th.joinable());
				} 
			}

			int main()
			{
				std::vector<std::thread> workers;
				test(workers);
				std::cout<<"Hi from main"<<std::endl;
				// Barrier
				std::for_each(workers.begin(), workers.end(), [](std::thread& th)
				{
					assert(th.joinable());
					th.join(); // waits for thread th to complete
				});
				return 0;
			}
	
	Shared memory between threads
		It's hard and can incurr into race conditions -> cases in which two or more threads works concurrently on the same data, without any synchronization -> some data gets lost.
		In the previous example, all the threads are accessing the same value, i, causing concurrent accesses

		~ Data race example

			struct List 
			{
				struct Node 
				{
					int _x;
					Node* _next;
					Node(int y) : _x(y), _next(nullptr) {} // constructor initialization list
				};
				// List
				Node* _head;
				List() : _head(nullptr) {}
				void insert(int x)
				{
					// In this portion of code the race condition may apply: the data of head can be accessed concurrently, and loose one or more nodes, overridden by others when _head = node lastly; 
					Node* node = new Node(x);
					node->next = _head;
					_head = node;
				}
				int count() const;
			}

			void thFun(List& list)
			{
				for(int i {0}; i < 100; ++i)
				{
					list.isert(i);
				}
			}

			int main()
			{
				List list;
				std::vector<std::thread> workers;
				for(int i {0}; i<10; ++i)
				{
					workers.push_back(std::thread(&thFun, std::ref(list))); // list does not go out of scope, since all the threads end before main ends
				}
				std::for_each(workers.begin(), workers.end(), [](std::thread& th)
				{
					th.join();
				});
				int total = list.count();
			}

			int List::count() const 
			{
				// count the nodes... 
			}
		
		~ Some good program 
			The main idea is to not have concurrent access to memory -> this avoid race conditions 
			The easiest way is to synchronize the program 

			void toSin(std::list<double>& list)
			{
				std::for_each(list.being(), list.end(), [](double& x) // the reference here allows to edit each list element directly!
				{
					x = sin(x);
				});
			}

			int main()
			{
				std::list<double> list;
				// access list from main thread
				const double pi = 3.141592;
				const double epsilon = 0.0000001;
				for(double x = 0.0; x < 2 * pi + epsilon; x += pi/16)
					list.push_back(x);
				// start thread
				std::thread th(&toSin, std::ref(list)); // remember that thread constructor needs to be explicitly told when parameters are lvalue or rvalue references
				// join thread
				th.join();
				// access list from main thread. This happens when the thread completes -> we are safe!
				// Main thread does not use the data structure list until the thread th completes
				// prints the sine wave
				std::for_each(list.begin(), list.end(), [](double& x)
				{
					int count = static_cast<int>(10*x + 10.5);
					for(int i {0}; i < count; ++i)
						std::cout.put('*');
					std::count << std::endl;
				});
			}
	
		~ Now let's try to move the List to the thread 
			What happens is that the list is moved to the thread, so the main thread remains with an empty list (since it has been moved to the worker thread)
			This is a way of moving around the data, by making sure that only one thread can access it 
				-> Literally "move" around.

			#include <thread>
			#include <algorith>
			#include <iostream>
			#include <list>
			#include <cmath>
			#include <chrono>

			void toSin(std::list<double>&& list)
			{
				// makes the current thread executing the function sleeps for one second
				std::this_thread::sleep_for(std::chrono::seconds(1));
				std::for_each(list.being(), list.end(), [](double& x) // the reference here allows to edit each list element directly!
				{
					x = sin(x);
				});
			}

			int main()
			{
				std::list<double> list;
				// access list from main thread
				const double pi = 3.141592;
				const double epsilon = 0.0000001;
				for(double x = 0.0; x < 2 * pi + epsilon; x += pi/16)
					list.push_back(x);
				// start thread
				std::thread th(&toSin, std::move(list)); // remember that thread constructor needs to be explicitly told when parameters are lvalue or rvalue references

				// prints the sine wave
				// Nothing will happen, since list has been moved to the other thread -> nothing remains on the main thread
				std::for_each(list.begin(), list.end(), [](double& x)
				{
					int count = static_cast<int>(10*x + 10.5);
					for(int i {0}; i < count; ++i)
						std::cout.put('*');
					std::count << std::endl;
				});
				// join thread
				th.join();
				// access list from main thread. This happens when the thread completes -> we are safe!
				// Main thread does not use the data structure list until the thread th completes
			}

	Future, Promise and Async (like task from c#)
		Makes the process of passing data around much easier!

		Promise and Future use a Shared State, which can be: 
			Not ready 
			Ready 
				With value 
				With exception 
			When consumed the state goes into invalid 
				Since the value inside the state can be moved -> calling get twice leads to an error

		~ Syntax 
			promise<string> prms; // the promise is create
			auto ftr = prms.get_future();
			thread th(&thFun, std::move(prms)); // the thread receives the promise
			std::string str = ftr.get(); // the main thread is blocked here until the state of the promise becomes ready

		~ Program that passes values between threads (promise passed by rval ref)
			#include <iostream>
			#include <string>
			#include <thread>
			#include <future> // library for promises and futures 

			void thFun(std::promise<std::string>&& prms)
			{
				std::string str("Hello from Future");
				prms.set_value(str); // This makes the status of the promise ready with a value 
			}

			int main()
			{
				std::promise<std::string> prms;
				std::future<std::string> ftr = prms.get_future();
				// Here the promise is moved (passed by rval ref) -> we must obtain the future before it is moved in the thread
				std::thread th(&thFun, std::move(prms));
				std::cout<<"Hello from main"<<std::endl;
				std::string str = future.get(); // The main thread stops here until the set_value is called on the promise
				// We are sure to obtain the string from thread after printing hello from main
				std::cout<<str<<std::endl;
				th.join(); // necessary to join the thread, otherwise the program could terminate before the threads spawned, leading to an orphaned thread!
			}

		~ Program that passes values between threads (promise passed by lval ref)
			We also note that the value contained in the promise is passed by MOVE! So it will have the same memory address
			This is due to the fact that we are passing around the state of the promise, so we move it (instead of copying it).

			#include <iostream>
			#include <string>
			#include <thread>
			#include <future> // library for promises and futures 

			void thFun(std::promise<std::string>& prms)
			{
				std::string str("Hello from Future");
				// Here we print the address of the string, which is the first address of the c-string contained -> obtained with data() on string 
				// then casted to (void*) to make it a generic pointer (see Cast to void* section)
				std::cout<<"String data: "<<(void *)str.data()<<std::endl;
				prms.set_value(str); // This makes the status of the promise ready with a value 
			}

			int main()
			{
				std::promise<std::string> prms;
				// Here the promise is moved (passed by rval ref) -> we must obtain the future before it is moved in the thread
				std::thread th(&thFun, std::ref(prms));
				std::cout<<"Hello from main"<<std::endl;
				// since we pass the promise by reference, we can move the get_future down, before the get()
				std::future<std::string> ftr = prms.get_future();
				std::string str = future.get(); // The main thread stops here until the set_value is called on the promise
				// It will print the same pointer as the call inside the thread -> str is passed around by rval ref
				std::cout<<"String data: "<<(void *)str.data()<<std::endl;
				std::cout<<str<<std::endl;
				th.join(); // necessary to join the thread, otherwise the program could terminate before the threads spawned, leading to an orphaned thread!
			}
		
		~ Exception management
			The exception is generated, stored into the promise state, and fetched from the get on the future 

			#include <iostream>
			#include <string>
			#include <thread>
			#include <future> // library for promises and futures 

			void thFun(std::promise<std::string>&& prms)
			{
				try{
					std::string str("Hello from Future");
					throw(std::exception("Exception from future!"));
					prms.set_value(str); // This makes the status of the promise ready with a value 
				}
				catch(...) // here we catch all possible exceptions, since we are not handling it, but just forwaring to the caller via the promise
				{
					prms.set_exception(std::current_exception()); // current exception retrieves the caught exception
					// the exception will be rethrown when another thread performs get on the future
				}
			}

			int main()
			{
				std::promise<std::string> prms;
				std::future<std::string> ftr = prms.get_future();
				// Here the promise is moved (passed by rval ref) -> we must obtain the future before it is moved in the thread
				std::thread th(&thFun, std::move(prms));
				std::cout<<"Hello from main"<<std::endl;
				try{
					std::string str = future.get(); // The main thread stops here until the set_value is called on the promise
					std::cout<<str<<std::endl;
				}
				catch(std::exception& e) // here we handle a specific exception -> be specific with the type 
				{
					// exception.what() gives the error message of the exception
					std::cout<<e.what()<<std::endl;
				}
				th.join(); // necessary to join the thread, otherwise the program could terminate before the threads spawned, leading to an orphaned thread!
			}

		~ A simpler way, with Async, that does all the previous operations automatically
			It's like a Task in C#

			#include <iostream>
			#include <string>
			#include <thread>
			#include <future> // library for promises and futures 

			std::string fun()
			{
				std::string str("Hello from future!");
				return str;
			}

			int main()
			{
				// async retunrs the same future returned by the promise
				// but we can avoid:
				// 			creating the thread manually
				//			getting the future from a promise 
				// 			passing a promise to the thread 
				// 			avoid thread.join() at the end to synchronize the executions
				auto ftr = std::async(&fun);
				std::cout<<"Hello from main"<<std::endl;
				// We are sure to obtain the string from thread after printing hello from main
				std::string str = ftr.get();
				std::cout<<str<<std::endl;
			}
		
		~ We can also manage exception in a simpler way
			There is no need anymore to catch and throw the exception in the thread function, passing to the promise 
			We have no promise, so we can simply throw it in the thread function 

			#include <iostream>
			#include <string>
			#include <thread>
			#include <future> // library for promises and futures 

			std::string fun()
			{
				std::string str("Hello from future!");
				throw(std::exception("Exception from Task"));
				return str;
			}

			int main()
			{
				// async retunrs the same future returned by the promise
				// but we can avoid:
				// 			creating the thread manually
				//			getting the future from a promise 
				// 			passing a promise to the thread 
				// 			avoid thread.join() at the end to synchronize the executions
				auto ftr = std::async(&fun);
				std::cout<<"Hello from main"<<std::endl;
				// We are sure to obtain the string from thread after printing hello from main
				try{
					std::string str = ftr.get();
				}
				catch(std::exception& e)
				{
					std::cout<<e.what()<<std::endl;
				}
				std::cout<<str<<std::endl;
			}

		~ What happens when the thread function does not return anythig?
			We do not expect any data, so there is no synchronization needed. 
			We could call future.get() and wait the completion of the thread execution, but we are not getting anything from it. 
			The only thing we want, is to make sure the thread completes before the main thread completes, avoiding orphan threads.
			This is guaranteed by the fact that when the main thread end, the future goes out of scope, and its destructor does the thread join. How cool!!!

			void fun()
			{
				std::cout<<"Starting task"<<std::endl;
				std::this_thread::sleep_for(std::chrono::seconds(8));
				std::cout<<"Ending task"<<<std::endl;
			}

			int main()
			{
				std::future ftr = std::async(&thFun);
				std::cout<<"Exiting from main"<<std::endl;
				// here fts goes out of scope, and its destructor joins the thread
			}

	Task Based vs Threads 
		Abstraction level
			Threads: low 
			Tasks: high
		Resource Usage 
			Threads: heavy weight 
			Tasks: lightweight
		Problem solving
			Threads: improve latency 
			Tasks: improve throughput

- Monads in cpp
	https://www.youtube.com/watch?v=vkcxgagQ4bM